#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2020 Pier Luigi Fiorini <pierluigi.fiorini@liri.io>
#
# SPDX-License-Identifier: MIT

import io
import os


class ParsingError(Exception):
    pass


class DesktopParser(object):
    def __init__(self, filename=None):
        self._content = dict()
        if filename:
            self.parse(filename)

    def parse(self, filename):
        content = self._content

        if not os.path.isfile(filename):
            raise ParsingError('"%s" is not a file' % filename)

        try:
            # Nowadays content is UTF-8, but legacy files can have different
            # encodings, including mixed encodings in the same file.
            # We don't even try to decode them, we rather silence the errors.
            fd = io.open(filename, 'r', encoding='utf-8', errors='replace')
        except IOError as e:
            raise e

        # Parse
        for line in fd:
            line = line.strip()
            if not line:
                continue
            elif line[0] == '#':
                continue
            elif line[0] == '[':
                current_group = line.lstrip('[').rstrip(']')
                if self.has_group(current_group):
                    raise ParsingError('Duplicate group "%s" in "%s"' % (current_group, filename))
                else:
                    content[current_group] = {}
            else:
                try:
                    key, value = line.split('=', 1)
                except ValueError:
                    raise ParsingError('Invalid line: %s in "%s"' % (line, filename))
                key = key.strip() # Spaces before/after '=' should be ignored
                try:
                    if self.has_key(key, current_group):
                        raise ParsingError('Duplicate key "%s" in group "%s" in "%s"' % (key, current_group, filename))
                    else:
                        content[current_group][key] = value.strip()
                except (IndexError, UnboundLocalError):
                    raise ParsingError('Parsing error on key, group missing in "%s"' % filename)
        fd.close()

        self.filename = filename

    def save(self, filename):
        fd = io.open(filename, 'w', encoding='utf-8')

        last_group = None
        for group in self._content.keys():
            if last_group:
                fd.write('\n')
            fd.write('[' + group + ']\n')
            last_group = group
            for key in sorted(self._content[group].keys()):
                fd.write('%s=%s\n' % (key, self._content[group][key]))

        fd.close()

    def groups(self):
        return self._content.keys()

    def has_group(self, group):
        return group in self._content

    def keys(self, group):
        return self._content[group].keys()

    def has_key(self, key, group=None):
        if not group:
            group = 'Desktop Entry'
        return key in self._content[group]

    def get(self, group, key):
        if self.has_key(key, group=group):
            return self._content[group][key]
        return None

    def set(self, group, key, value):
        self._content[group][key] = value


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('--source', type=str, required=True, help='Desktop file template')
    parser.add_argument('--dest', type=str, required=True, help='Desktop file')
    parser.add_argument('translations', action='append', nargs='*', help='Translations')
    args = parser.parse_args()

    # Load the template
    parser = DesktopParser(args.source)

    # Load all the translated entries and merge theme with the source
    for filename in args.translations[0]:
        translation = DesktopParser(filename)
        for group in translation.groups():
            for key in translation.keys(group):
                if '[' in key and ']' in key and not key.startswith('Icon'):
                    parser.set(group, key, translation.get(group, key))

    # Write the translated desktop file
    parser.save(args.dest)
